<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Quizzes â€” EXCELlent AccounTax</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Uses the shared site-wide stylesheet as basis for formats -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <!-- Sticky tabs -->
  <header class="topbar" role="navigation" aria-label="Primary">
    <nav class="tabs">
      <a class="tab" href="#home" data-tab="home">Home</a>
      <a class="tab" href="#glossary" data-tab="glossary">Glossary</a>
      <a class="tab active" href="#quizzes" data-tab="quizzes">Quizzes</a>
      <a class="tab" href="#references" data-tab="references">References</a>
      <a class="tab" href="#visuals" data-tab="visuals">Visuals</a>
      <a class="tab" href="#tools" data-tab="tools">Tools</a>
    </nav>
  </header>

  <!-- Sticky filters and actions -->
  <div class="actionbar" role="region" aria-label="Quiz filters and actions">
    <div class="actionbar-inner">
      <div class="select">
        <label for="volume">Volume</label>
        <select id="volume">
          <option value="">Select volume</option>
          <option value="1">Volume 1</option>
          <option value="2">Volume 2</option>
          <option value="3">Volume 3</option>
        </select>
      </div>

      <div class="select">
        <label for="chapter">Chapter</label>
        <select id="chapter" disabled>
          <option value="">Select chapter</option>
        </select>
      </div>

      <div class="select">
        <label for="topic">Topic</label>
        <select id="topic" disabled>
          <option value="">Select topic</option>
        </select>
      </div>

      <div class="select">
        <label for="qtype">Question type</label>
        <select id="qtype" disabled>
          <option value="">Select type</option>
          <option value="theory">Theory</option>
          <option value="practice">Practice</option>
          <option value="both">Both</option>
        </select>
      </div>

      <div class="actions">
        <button id="submitBtn" class="btn primary" disabled>Submit</button>
        <button id="resetBtn" class="btn secondary" disabled>Reset</button>
      </div>
    </div>
  </div>

  <!-- Main content -->
  <main class="container">
    <section id="quizzesPanel" class="panel">
      <p class="filters-note">
        Use the selectors above to load questions. Tabs remain clickable even when you scroll.
      </p>

      <div id="content"></div>

      <div id="scoreboard" class="scoreboard hidden" aria-live="polite">
        <div class="score">
          <label>Raw score</label>
          <strong id="rawScore">0 / 0</strong>
        </div>
        <div class="score">
          <label>Percentage</label>
          <strong id="pctScore">0%</strong>
        </div>
      </div>
    </section>
  </main>

  <!-- Scripts -->
  <script>
    // State
    const state = {
      volume: "",
      chapter: "",
      topic: "",
      qtype: "",
      submitted: false
    };

    // Elements
    const volumeSel = document.getElementById('volume');
    const chapterSel = document.getElementById('chapter');
    const topicSel = document.getElementById('topic');
    const qtypeSel = document.getElementById('qtype');
    const contentEl = document.getElementById('content');
    const submitBtn = document.getElementById('submitBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreboard = document.getElementById('scoreboard');
    const rawScoreEl = document.getElementById('rawScore');
    const pctScoreEl = document.getElementById('pctScore');

    // Tabs activation (visual only; anchors remain clickable)
    function activateTab(name){
      document.querySelectorAll('.tab').forEach(a=>{
        a.classList.toggle('active', a.dataset.tab === name);
      });
    }
    document.querySelectorAll('.tab').forEach(tab=>{
      tab.addEventListener('click', ()=> activateTab(tab.dataset.tab));
    });

    // Reset UI shell
    function clearUI(){
      state.submitted = false;
      contentEl.innerHTML = '';
      scoreboard.classList.add('hidden');
      rawScoreEl.textContent = '0 / 0';
      pctScoreEl.textContent = '0%';
    }

    // Populate selects (chapters and topics will be hydrated in the next batch)
    function populateChapters(volKey){
      chapterSel.innerHTML = '<option value="">Select chapter</option>';
      topicSel.innerHTML = '<option value="">Select topic</option>';
      chapterSel.disabled = true;
      topicSel.disabled = true;
      qtypeSel.value = "";
      qtypeSel.disabled = true;
      submitBtn.disabled = true;
      resetBtn.disabled = false;
    }
    function populateTopics(){
      topicSel.innerHTML = '<option value="">Select topic</option>';
      topicSel.disabled = true;
      qtypeSel.value = "";
      qtypeSel.disabled = true;
      submitBtn.disabled = true;
    }

    // Enable type when ready
    function enableTypeIfReady(){
      const ready = !!(state.volume && state.chapter && state.topic);
      qtypeSel.disabled = !ready;
      submitBtn.disabled = true;
      resetBtn.disabled = false;
    }

    // Event bindings (data hydration and rendering will come in Batch 2)
    volumeSel.addEventListener('change', ()=>{
      state.volume = volumeSel.value;
      state.chapter = "";
      state.topic = "";
      state.qtype = "";
      populateChapters(state.volume);
      clearUI();
    });

    chapterSel.addEventListener('change', ()=>{
      state.chapter = chapterSel.value;
      state.topic = "";
      state.qtype = "";
      populateTopics();
      clearUI();
    });

    topicSel.addEventListener('change', ()=>{
      state.topic = topicSel.value;
      enableTypeIfReady();
      clearUI();
    });

    qtypeSel.addEventListener('change', ()=>{
      state.qtype = qtypeSel.value;
      clearUI(); // Rendering comes in Batch 2
      submitBtn.disabled = !state.qtype;
    });

    submitBtn.addEventListener('click', ()=>{
      // Evaluation and reveals will be implemented in Batch 3
    });

    resetBtn.addEventListener('click', ()=>{
      state.volume = "";
      state.chapter = "";
      state.topic = "";
      state.qtype = "";
      state.submitted = false;

      volumeSel.value = "";
      populateChapters("");
      chapterSel.value = "";
      topicSel.value = "";
      qtypeSel.value = "";
      chapterSel.disabled = true;
      topicSel.disabled = true;
      qtypeSel.disabled = true;
      submitBtn.disabled = true;
      resetBtn.disabled = true;

      clearUI();
      volumeSel.focus();
    });

    // Bootstrap
    resetBtn.disabled = true;
    activateTab('quizzes');
  </script>
</body>
</html>

<script>
// ==========================
// Batch 2: Data + Rendering
// ==========================

// Quiz data
const DATA = {
  volumes: {
    "1": {
      label: "Volume 1",
      chapters: {
        "1": {
          label: "Chapter 1: Cash and Cash Equivalents",
          topics: {
            "1.6": {
              label: "1.6 Quiz on Cash and Cash Equivalents",
              theory: [
                {
                  id: "ThQ1",
                  stem: "Cash on hand includes:",
                  choices: [
                    "Checks dated less than 6 months after today.",
                    "Checks dated less than 6 months before today.",
                    "Checks dated more than 6 months after today.",
                    "Checks dated more than 6 months before today."
                  ],
                  correctIndex: 1
                },
                {
                  id: "ThQ2",
                  stem: "In defining cash equivalents, known maturity value denotes:",
                  choices: [
                    "Maturity date is determinable on acquisition date.",
                    "Maturity value is determinable on acquisition date.",
                    "Maturity value will be determined on maturity date.",
                    "Maturity value will be known on maturity date."
                  ],
                  correctIndex: 1
                },
                {
                  id: "ThQ3",
                  stem: "Which are excluded from cash equivalents?",
                  choices: [
                    "Credit cards receivable.",
                    "Debit cards receivable.",
                    "Time deposits downgraded lower than savings accounts when pre-terminated.",
                    "Time deposits downgraded not lower than savings accounts when pre-terminated."
                  ],
                  correctIndex: 2
                },
                {
                  id: "ThQ4",
                  stem: "Which are classified as restricted cash, and presented as noncurrent assets?",
                  choices: [
                    "Currency usable for at least 12 months after the reporting period.",
                    "Currency usable for less than 12 months after the reporting period.",
                    "Currency usable for more than 12 months after the reporting period.",
                    "Currency usable within 12 months after the reporting period."
                  ],
                  correctIndex: 0
                },
                {
                  id: "ThQ5",
                  stem: "Which are classified as short-term investments, and presented as current assets?",
                  choices: [
                    "Bank deposits withdrawable with insignificant penalty and usable for less than 12 months.",
                    "Bank deposits withdrawable with significant penalty and usable for more than 12 months.",
                    "Bank deposits withdrawable with significant penalty and usable within 12 months.",
                    "Bank deposits withdrawable without penalty and usable for less than 12 months."
                  ],
                  correctIndex: 2
                },
                {
                  id: "ThQ6",
                  stem: "These describe a bank overdraft, except:",
                  choices: [
                    "It is allowed only if caused by normal bank charges or other incidental handling fees.",
                    "It is disallowed in the Philippines.",
                    "It is known as temporary overdrawing in the Philippines.",
                    "It is the negative (or overdrawn) balance in a demand deposit account."
                  ],
                  correctIndex: 1
                },
                {
                  id: "ThQ7",
                  stem: "Check withdrawals are recorded as:",
                  choices: [
                    "Debit to Demand Deposits of depositor entity and credit to Deposit Liabilities of financial institution.",
                    "Debit to Demand Deposits of financial institution and credit to Deposit Liabilities of depositor entity.",
                    "Debit to Deposit Liabilities of depositor entity and credit to Demand Deposits of financial institution.",
                    "Debit to Deposit Liabilities of financial institution and credit to Demand Deposits of depositor entity."
                  ],
                  correctIndex: 3
                },
                {
                  id: "ThQ8",
                  stem: "Timing differences for Deposit Liabilities of financial institution comprise:",
                  choices: [
                    "Credit memos and debit memos.",
                    "Outstanding checks and debit memos.",
                    "Outstanding deposits and credit memos.",
                    "Outstanding deposits and outstanding checks."
                  ],
                  correctIndex: 3
                },
                {
                  id: "ThQ9",
                  stem: "Which describe debit memos?",
                  choices: [
                    "They are already credited to Demand Deposits but not yet debited to Deposit Liabilities.",
                    "They are already credited to Deposit Liabilities but not yet debited to Demand Deposits.",
                    "They are already debited to Demand Deposits but not yet credited to Deposit Liabilities.",
                    "They are already debited to Deposit Liabilities but not yet credited to Demand Deposits."
                  ],
                  correctIndex: 3
                },
                {
                  id: "ThQ10",
                  stem: "Before replenishment, the adjusted balance of Petty Cash Fund equals:",
                  choices: [
                    "Currency in the custody of the Petty Cash Custodian.",
                    "Established amount.",
                    "Minimum threshold.",
                    "Total of Petty Cash Vouchers."
                  ],
                  correctIndex: 0
                }
              ],
              practice: [
                {
                  id: "PrQ1",
                  stem: "With these givens, the closing outstanding checks are:",
                  questionImage: "images/IntaccV1C01CashAndCashEquivalentsPq01.png",
                  choices: [
                    "289,000.00.",
                    "311,000.00.",
                    "489,000.00.",
                    "511,000.00."
                  ],
                  correctIndex: 1,
                  answerImage: "images/IntaccV1C01CashAndCashEquivalentsPa01.png"
                },
                {
                  id: "PrQ2",
                  stem: "With these givens, the opening outstanding checks are:",
                  questionImage: "images/IntaccV1C01CashAndCashEquivalentsPq02.png",
                  choices: [
                    "289,000.00.",
                    "311,000.00.",
                    "489,000.00.",
                    "511,000.00."
                  ],
                  correctIndex: 1,
                  answerImage: "images/IntaccV1C01CashAndCashEquivalentsPa02.png"
                },
                {
                  id: "PrQ3",
                  stem: "With these givens, the closing book balance is:",
                  questionImage: "images/IntaccV1C01CashAndCashEquivalentsPq03.png",
                  choices: [
                    "2,496,000.00.",
                    "2,499,800.00.",
                    "2,500,200.00.",
                    "2,504,000.00."
                  ],
                  correctIndex: 1,
                  answerImage: "images/IntaccV1C01CashAndCashEquivalentsPa03.png"
                },
                {
                  id: "PrQ4",
                  stem: "With these givens, the closing outstanding deposits are:",
                  questionImage: "images/IntaccV1C01CashAndCashEquivalentsPq04.png",
                  choices: [
                    "487,000.00.",
                    "513,000.00.",
                    "887,000.00.",
                    "913,000.00."
                  ],
                  correctIndex: 3,
                  answerImage: "images/IntaccV1C01CashAndCashEquivalentsPa04.png"
                },
                {
                  id: "PrQ5",
                  stem: "With these givens, the closing outstanding deposits are:",
                  questionImage: "images/IntaccV1C01CashAndCashEquivalentsPq05.png",
                  choices: [
                    "398,700.00.",
                    "398,900.00.",
                    "898,700.00.",
                    "898,900.00."
                  ],
                  correctIndex: 2,
                  answerImage: "images/IntaccV1C01CashAndCashEquivalentsPa05.png"
                }
              ]
            }
          }
        }
      }
    },
    "2": { label: "Volume 2", chapters: {} },
    "3": { label: "Volume 3", chapters: {} }
  }
};

// Populate chapters based on volume
function populateChapters(volKey){
  chapterSel.innerHTML = '<option value="">Select chapter</option>';
  topicSel.innerHTML = '<option value="">Select topic</option>';
  chapterSel.disabled = true;
  topicSel.disabled = true;
  qtypeSel.value = "";
  qtypeSel.disabled = true;
  submitBtn.disabled = true;
  resetBtn.disabled = false;

  const vol = DATA.volumes[volKey];
  if(!vol) return;

  const chapters = vol.chapters || {};
  Object.keys(chapters).forEach(chKey=>{
    const opt = document.createElement('option');
    opt.value = chKey;
    opt.textContent = chapters[chKey].label || `Chapter ${chKey}`;
    chapterSel.appendChild(opt);
  });
  chapterSel.disabled = Object.keys(chapters).length === 0;
}

// Populate topics based on chapter
function populateTopics(volKey, chKey){
  topicSel.innerHTML = '<option value="">Select topic</option>';
  topicSel.disabled = true;
  qtypeSel.value = "";
  qtypeSel.disabled = true;
  submitBtn.disabled = true;

  const ch = DATA.volumes?.[volKey]?.chapters?.[chKey];
  if(!ch) return;

  const topics = ch.topics || {};
  Object.keys(topics).forEach(tk=>{
    const opt = document.createElement('option');
    opt.value = tk;
    opt.textContent = topics[tk].label || `Topic ${tk}`;
    topicSel.appendChild(opt);
  });
  topicSel.disabled = Object.keys(topics).length === 0;
}

// Render questions based on selection
function renderQuestions(){
  clearUI();

  const topicObj = DATA.volumes?.[state.volume]?.chapters?.[state.chapter]?.topics?.[state.topic];
  if(!topicObj){
    contentEl.innerHTML = '<p class="muted">No questions available for this selection yet.</p>';
    return;
  }

  const showTheory = state.qtype === 'theory' || state.qtype === 'both';
  const showPractice = state.qtype === 'practice' || state.qtype === 'both';
  const blocks = [];

  if(showTheory && Array.isArray(topicObj.theory) && topicObj.theory.length){
    blocks.push(renderTheorySection(topicObj.theory));
  }
  if(showPractice && Array.isArray(topicObj.practice) && topicObj.practice.length){
    blocks.push(renderPracticeSection(topicObj.practice));
  }

  if(blocks.length === 0){
    contentEl.innerHTML = '<p class="muted">No questions available for this selection.</p>';
  } else {
    contentEl.append(...blocks);
  }

  const hasQuestions = contentEl.querySelectorAll('.q').length > 0;
  submitBtn.disabled = !hasQuestions;
  resetBtn.disabled = false;
}

// Render theory section
function renderTheorySection(items){
  const wrap = document.createElement('div');
  const h = document.createElement('h3');
  h.className = 'section-heading';
  h.textContent = 'Theory questions';
  wrap.appendChild(h);

  items.forEach((q, idx)=>{
    const qEl = renderTheoryQuestion(q, idx+1);
    wrap.appendChild(qEl);
  });

  return wrap;
}

// Render practice section
function renderPracticeSection(items){
  const wrap = document.createElement('div');
  const h = document.createElement('h3');
  h.className = 'section-heading';
  h.textContent = 'Practice questions';
  wrap.appendChild(h);

  items.forEach((q, idx)=>{
    const qEl = renderPracticeQuestion(q, idx+1);
    wrap.appendChild(qEl);
  });

  return wrap;
}

// Render a single theory question
function renderTheoryQuestion(q, number){
  const qId = q.id || `ThQ_${number}`;
  const qWrap = document.createElement('div');
  qWrap.className = 'q';
  qWrap.dataset.qid = qId;
  qWrap.dataset.kind = 'theory';
  qWrap.innerHTML = `
    <div class="q-meta">Theory Question ${number}</div>
    <h4 class="q-stem">${escapeHtml(q.stem)}</h4>
    <div class="choices" role="radiogroup" aria-label="Theory Question ${number} choices">
      ${q.choices.map((c, i)=> `
        <label class="choice">
          <input type="radio" name="${qId}" value="${i}" />
          <span class="letter">${String.fromCharCode(65+i)}.</span>
          <span>${escapeHtml(c)}</span>
        </label>
      `).join('')}
    </div>
    <div class="feedback hidden" aria-live="polite"></div>
    <div class="reveals hidden"></div>
  `;
  return qWrap;
}

// Render a single practice question
function renderPracticeQuestion(q, number){
  const qId = q.id || `PrQ_${number}`;
  const qWrap = document.createElement('div');
  qWrap.className = 'q';
  qWrap.dataset.qid = qId;
  qWrap.dataset.kind = 'practice';
  qWrap.innerHTML = `
    <div class="q-meta">Practice Question ${number}</div>
    <h4 class="q-stem">${escapeHtml(q.stem)}</h4>
    <div class="q-media">
      <figure>
        <img src="${escapeAttr(q.questionImage)}" alt="Practice Question ${number} image" />
        <figcaption>Question exhibit</figcaption>
      </figure>
    </div>
    <div class="choices" role="radiogroup" aria-label="Practice Question ${number} choices">
      ${q.choices.map((c, i)=> `
        <label class="choice">
          <input type="radio" name="${qId}" value="${i}" />
          <span class="letter">${String.fromCharCode(65+i)}.</span>
          <span>${escapeHtml(c)}</span>
        </label>
      `).join('')}
    </div>
    <div class="feedback hidden" aria-live="polite"></div>
    <div class="reveals hidden"></div>
  `;
  return qWrap;
}

// Utility functions
function escapeHtml(s){
  return String(s)
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}
function escapeAttr(s){
  return escapeHtml(s);
}
</script>

<script>
// ==========================
// Batch 3: Submit / Reveal / Score
// ==========================

// Find a question object by its ID
function findQuestionById(qid){
  const t = DATA.volumes?.[state.volume]?.chapters?.[state.chapter]?.topics?.[state.topic];
  if(!t) return null;
  const all = [
    ...(t.theory || []),
    ...(t.practice || [])
  ];
  return all.find(x => x.id === qid) || null;
}

// Handle submit
function onSubmit(){
  const qNodes = Array.from(contentEl.querySelectorAll('.q'));
  if(!qNodes.length) return;

  let total = 0;
  let correct = 0;

  qNodes.forEach(qn=>{
    const kind = qn.dataset.kind;
    const qid = qn.dataset.qid;
    const radios = qn.querySelectorAll('input[type="radio"]');
    const selected = Array.from(radios).find(r => r.checked);
    const reveal = qn.querySelector('.reveals');
    const feedback = qn.querySelector('.feedback');

    const qData = findQuestionById(qid);
    if(!qData) return;

    total += 1;
    const userIndex = selected ? parseInt(selected.value,10) : -1;
    const isCorrect = userIndex === qData.correctIndex;

    // Feedback
    feedback.classList.remove('hidden', 'correct', 'incorrect');
    feedback.classList.add(isCorrect ? 'correct' : 'incorrect');
    feedback.innerHTML = `
      <span class="status">${isCorrect ? 'Correct' : 'Incorrect'}</span>
      ${selected ? '' : '<span class="muted"> (no answer selected)</span>'}
    `;

    // Reveal correct answer
    const correctLetter = String.fromCharCode(65 + qData.correctIndex);
    const correctText = qData.choices[qData.correctIndex];

    reveal.classList.remove('hidden');
    reveal.innerHTML = `
      <div><span class="tag">Answer</span> ${correctLetter}. ${escapeHtml(correctText)}</div>
    `;

    // If practice, show answer image
    if(kind === 'practice' && qData.answerImage){
      const am = document.createElement('div');
      am.className = 'answer-media';
      am.innerHTML = `
        <figure>
          <img src="${escapeAttr(qData.answerImage)}" alt="Practice answer image for ${qid}" />
          <figcaption>Answer exhibit</figcaption>
        </figure>
      `;
      reveal.appendChild(am);
    }

    // Lock choices
    radios.forEach(r => r.disabled = true);

    if(isCorrect) correct += 1;
  });

  // Scoreboard
  const pct = total ? Math.round((correct/total)*100) : 0;
  rawScoreEl.textContent = `${correct} / ${total}`;
  pctScoreEl.textContent = `${pct}%`;
  scoreboard.classList.remove('hidden');

  state.submitted = true;
}

// Wire up submit to render logic
submitBtn.addEventListener('click', onSubmit);

// When qtype changes, render questions
qtypeSel.addEventListener('change', ()=>{
  state.qtype = qtypeSel.value;
  if(state.qtype){
    renderQuestions();
  } else {
    clearUI();
    submitBtn.disabled = true;
  }
});
</script>
